import Foundation
import PDFKit
import SwiftUI

enum ExportFormat {
    case csv
    case pdf
    case analytics
}

class ExportService {
    static func exportExpenses(_ expenses: [Expense], accounts: [Account], format: ExportFormat, startDate: Date? = nil, endDate: Date? = nil) -> URL? {
        switch format {
        case .analytics:
            return AnalyticsReportService.generateReport(expenses: expenses, accounts: accounts, startDate: startDate, endDate: endDate)
        default:
            // Filter expenses by date range if provided
            let filteredExpenses = expenses.filter { expense in
                let afterStart = startDate.map { Calendar.current.startOfDay(for: expense.date) >= Calendar.current.startOfDay(for: $0) } ?? true
                let beforeEnd = endDate.map { Calendar.current.startOfDay(for: expense.date) <= Calendar.current.startOfDay(for: $0) } ?? true
                return afterStart && beforeEnd
            }
            
            // Sort expenses by date for better readability
            let sortedExpenses = filteredExpenses.sorted { $0.date > $1.date }
            
            switch format {
            case .csv:
                return exportToCSV(sortedExpenses, accounts: accounts, startDate: startDate, endDate: endDate)
            case .pdf:
                return exportToPDF(sortedExpenses, accounts: accounts, startDate: startDate, endDate: endDate)
            case .analytics:
                return nil // Already handled above
            }
        }
    }
    
    private static func exportToCSV(_ expenses: [Expense], accounts: [Account], startDate: Date?, endDate: Date?) -> URL? {
        // Create formatters
        let dateFormatter = DateFormatter()
        dateFormatter.dateStyle = .medium
        dateFormatter.timeStyle = .none
        
        let currencyFormatter = NumberFormatter()
        currencyFormatter.numberStyle = .currency
        currencyFormatter.locale = Locale.current
        
        // Create CSV content
        var csvRows: [String] = []
        
        // Add headers
        csvRows.append("Date,Description,Amount,Category,Account")
        
        // Add data rows
        for expense in expenses {
            let accountName = accounts.first { $0.id == expense.accountId }?.name ?? "Unknown Account"
            
            // Format the amount with the currency formatter
            let amountStr = currencyFormatter.string(from: NSNumber(value: expense.amount)) ?? String(format: "%.2f", expense.amount)
            
            // Escape fields that might contain commas or quotes
            let description = escapeCSVField(expense.description)
            let escapedAccountName = escapeCSVField(accountName)
            
            let row = [
                escapeCSVField(dateFormatter.string(from: expense.date)),
                description,
                escapeCSVField(amountStr),
                escapeCSVField(expense.category.rawValue),
                escapedAccountName
            ].joined(separator: ",")
            
            csvRows.append(row)
        }
        
        // Join all rows with newlines
        let csvString = csvRows.joined(separator: "\n")
        
        // Write to file
        let fileURL = FileManager.default.temporaryDirectory.appendingPathComponent("expenses.csv")
        do {
            try csvString.write(to: fileURL, atomically: true, encoding: .utf8)
            return fileURL
        } catch {
            print("Error writing CSV: \(error)")
            return nil
        }
    }
    
    private static func escapeCSVField(_ field: String) -> String {
        let needsEscaping = field.contains(",") || field.contains("\"") || field.contains("\n")
        if needsEscaping {
            // Replace double quotes with two double quotes and wrap in quotes
            let escapedField = field.replacingOccurrences(of: "\"", with: "\"\"")
            return "\"\(escapedField)\""
        }
        return field
    }
    
    private static func exportToPDF(_ expenses: [Expense], accounts: [Account], startDate: Date?, endDate: Date?) -> URL? {
        // Create PDF document
        let pdfMetaData = [
            kCGPDFContextCreator: "ExpenseTracker",
            kCGPDFContextAuthor: "Generated by ExpenseTracker"
        ]
        let format = UIGraphicsPDFRendererFormat()
        format.documentInfo = pdfMetaData as [String: Any]
        
        // Standard US Letter size (8.5 x 11 inches)
        let pageWidth = 8.5 * 72.0
        let pageHeight = 11.0 * 72.0
        let pageRect = CGRect(x: 0, y: 0, width: pageWidth, height: pageHeight)
        
        // Define margins
        let margin: CGFloat = 50  // ~0.7 inch margins
        let contentWidth = pageWidth - (margin * 2)
        
        // Define column widths (total should equal contentWidth)
        let columnWidths: [CGFloat] = [
            contentWidth * 0.15,  // Date (15%)
            contentWidth * 0.35,  // Description (35%)
            contentWidth * 0.15,  // Amount (15%)
            contentWidth * 0.15,  // Category (15%)
            contentWidth * 0.20   // Account (20%)
        ]
        
        let pdfRenderer = UIGraphicsPDFRenderer(bounds: pageRect, format: format)
        let fileURL = FileManager.default.temporaryDirectory.appendingPathComponent("expenses.pdf")
        
        let dateFormatter = DateFormatter()
        dateFormatter.dateStyle = .medium
        
        let currencyFormatter = NumberFormatter()
        currencyFormatter.numberStyle = .currency
        currencyFormatter.locale = Locale.current
        
        do {
            try pdfRenderer.writePDF(to: fileURL) { context in
                var pageNumber = 1
                var currentY: CGFloat = 0
                var remainingExpenses = expenses
                
                // Function to draw the header section
                func drawHeader() {
                    currentY = margin
                    
                    // Define common attributes
                    let titleAttributes: [NSAttributedString.Key: Any] = [
                        .font: UIFont.boldSystemFont(ofSize: 24)
                    ]
                    let dateAttributes: [NSAttributedString.Key: Any] = [
                        .font: UIFont.systemFont(ofSize: 12)
                    ]
                    
                    // Add title
                    let title = "Expense Report"
                    title.draw(at: CGPoint(x: margin, y: currentY), withAttributes: titleAttributes)
                    
                    currentY += 30
                    
                    // Add date range with better formatting
                    let dateRange: String
                    if let start = startDate, let end = endDate {
                        dateRange = "Period: \(dateFormatter.string(from: start)) to \(dateFormatter.string(from: end))"
                    } else if !expenses.isEmpty {
                        let oldestDate = expenses.last?.date ?? Date()
                        let newestDate = expenses.first?.date ?? Date()
                        dateRange = "Period: \(dateFormatter.string(from: oldestDate)) to \(dateFormatter.string(from: newestDate))"
                    } else {
                        dateRange = "No expenses in selected period"
                    }
                    dateRange.draw(at: CGPoint(x: margin, y: currentY), withAttributes: dateAttributes)
                    
                    currentY += 20
                    
                    // Add summary
                    let totalExpenses = expenses.reduce(0.0) { $0 + $1.amount }
                    let summaryString = "Total Expenses: \(currencyFormatter.string(from: NSNumber(value: totalExpenses)) ?? String(format: "%.2f", totalExpenses))"
                    summaryString.draw(at: CGPoint(x: margin, y: currentY), withAttributes: dateAttributes)
                    
                    // Add category summary
                    currentY += 20
                    var categoryTotals: [Category: Double] = [:]
                    for expense in expenses {
                        categoryTotals[expense.category, default: 0] += expense.amount
                    }
                    
                    let categorySummary = "Top Categories: " + categoryTotals.sorted { $0.value > $1.value }
                        .prefix(3)
                        .map { "\($0.key.rawValue) (\(currencyFormatter.string(from: NSNumber(value: $0.value)) ?? String(format: "%.2f", $0.value)))" }
                        .joined(separator: ", ")
                    
                    categorySummary.draw(at: CGPoint(x: margin, y: currentY), withAttributes: dateAttributes)
                    
                    currentY += 40
                    
                    // Draw table headers
                    let headers = ["Date", "Description", "Amount", "Category", "Account"]
                    var xPosition = margin
                    
                    // Draw header background
                    context.cgContext.setFillColor(UIColor.lightGray.withAlphaComponent(0.2).cgColor)
                    context.cgContext.fill(CGRect(x: margin, y: currentY - 5, width: contentWidth, height: 25))
                    
                    let headerAttributes: [NSAttributedString.Key: Any] = [
                        .font: UIFont.boldSystemFont(ofSize: 12)
                    ]
                    
                    for (index, header) in headers.enumerated() {
                        header.draw(at: CGPoint(x: xPosition + 5, y: currentY), withAttributes: headerAttributes)
                        xPosition += columnWidths[index]
                    }
                    
                    currentY += 25
                }
                
                // Function to draw footer with page number
                func drawFooter() {
                    let footerAttributes: [NSAttributedString.Key: Any] = [
                        .font: UIFont.systemFont(ofSize: 10)
                    ]
                    
                    let pageText = "Page \(pageNumber)"
                    let dateText = "Generated on \(dateFormatter.string(from: Date()))"
                    
                    pageText.draw(at: CGPoint(x: pageWidth - margin - 50, y: pageHeight - margin), withAttributes: footerAttributes)
                    dateText.draw(at: CGPoint(x: margin, y: pageHeight - margin), withAttributes: footerAttributes)
                }
                
                // Start first page
                context.beginPage()
                drawHeader()
                
                // Draw content
                let contentAttributes: [NSAttributedString.Key: Any] = [
                    .font: UIFont.systemFont(ofSize: 10)
                ]
                
                while !remainingExpenses.isEmpty {
                    if currentY > pageHeight - (margin + 50) {
                        drawFooter()
                        pageNumber += 1
                        context.beginPage()
                        drawHeader()
                    }
                    
                    let expense = remainingExpenses.removeFirst()
                    var xPosition = margin
                    let accountName = accounts.first { $0.id == expense.accountId }?.name ?? "Unknown Account"
                    
                    let rowData = [
                        dateFormatter.string(from: expense.date),
                        expense.description,
                        currencyFormatter.string(from: NSNumber(value: expense.amount)) ?? String(format: "%.2f", expense.amount),
                        expense.category.rawValue,
                        accountName
                    ]
                    
                    // Draw alternating row background
                    if (expenses.count - remainingExpenses.count) % 2 == 0 {
                        context.cgContext.setFillColor(UIColor.lightGray.withAlphaComponent(0.1).cgColor)
                        context.cgContext.fill(CGRect(x: margin, y: currentY - 5, width: contentWidth, height: 20))
                    }
                    
                    // Draw row content
                    for (index, item) in rowData.enumerated() {
                        let itemWidth = columnWidths[index]
                        
                        // Calculate text width and apply truncation if needed
                        let itemSize = (item as NSString).size(withAttributes: contentAttributes)
                        var displayText = item
                        if itemSize.width > itemWidth - 10 {
                            displayText = item.prefix(Int(itemWidth / 8)).description + "..."
                        }
                        
                        // Right-align amounts
                        if index == 2 { // Amount column
                            let textWidth = (displayText as NSString).size(withAttributes: contentAttributes).width
                            displayText.draw(at: CGPoint(x: xPosition + itemWidth - textWidth - 5, y: currentY), withAttributes: contentAttributes)
                        } else {
                            displayText.draw(at: CGPoint(x: xPosition + 5, y: currentY), withAttributes: contentAttributes)
                        }
                        
                        xPosition += columnWidths[index]
                    }
                    
                    currentY += 20
                }
                
                // Draw footer on the last page
                drawFooter()
            }
            return fileURL
        } catch {
            print("Error creating PDF: \(error)")
            return nil
        }
    }
} 
